{"ast":null,"code":"class WebSocketManager {\n  constructor() {\n    this.ws = null;\n    this.listeners = [];\n    this.messageQueue = []; // Add a queue for messages\n    this.isConnected = false; // Track connection state\n  }\n  connect(url) {\n    if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {\n      console.log('Attempting to connect to WebSocket server...');\n      this.ws = new WebSocket(url);\n      this.ws.onopen = () => {\n        console.log('Connected to WebSocket server');\n        this.isConnected = true;\n\n        // Process any queued messages\n        while (this.messageQueue.length > 0) {\n          const message = this.messageQueue.shift();\n          this.sendImmediately(message);\n        }\n      };\n      this.ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('Parsed message:', data);\n          this.listeners.forEach(listener => listener(data));\n        } catch (error) {\n          console.error('Error parsing message:', error);\n        }\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket error:', error);\n        this.isConnected = false;\n      };\n      this.ws.onclose = () => {\n        console.log('WebSocket connection closed');\n        this.isConnected = false;\n        // Attempt to reconnect\n        setTimeout(() => this.connect(url), 3000);\n      };\n    }\n  }\n  sendImmediately(message) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      const messageString = JSON.stringify(message);\n      console.log('Sending message:', messageString);\n      this.ws.send(messageString);\n      return true;\n    }\n    return false;\n  }\n  send(message) {\n    if (this.isConnected && this.sendImmediately(message)) {\n      return true;\n    } else {\n      console.log('Queueing message because connection is not ready:', message);\n      this.messageQueue.push(message);\n      return false;\n    }\n  }\n  addListener(listener) {\n    this.listeners.push(listener);\n  }\n  removeListener(listener) {\n    this.listeners = this.listeners.filter(l => l !== listener);\n  }\n}\nconst webSocketManager = new WebSocketManager();\nexport default webSocketManager;","map":{"version":3,"names":["WebSocketManager","constructor","ws","listeners","messageQueue","isConnected","connect","url","readyState","WebSocket","CLOSED","console","log","onopen","length","message","shift","sendImmediately","onmessage","event","data","JSON","parse","forEach","listener","error","onerror","onclose","setTimeout","OPEN","messageString","stringify","send","push","addListener","removeListener","filter","l","webSocketManager"],"sources":["C:/Users/andra/Desktop/Projects/suduoku-java/frontend/src/components/WebSocketManager.js"],"sourcesContent":["class WebSocketManager {\r\n    constructor() {\r\n      this.ws = null;\r\n      this.listeners = [];\r\n      this.messageQueue = []; // Add a queue for messages\r\n      this.isConnected = false; // Track connection state\r\n    }\r\n  \r\n    connect(url) {\r\n      if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {\r\n        console.log('Attempting to connect to WebSocket server...');\r\n        this.ws = new WebSocket(url);\r\n  \r\n        this.ws.onopen = () => {\r\n          console.log('Connected to WebSocket server');\r\n          this.isConnected = true;\r\n          \r\n          // Process any queued messages\r\n          while (this.messageQueue.length > 0) {\r\n            const message = this.messageQueue.shift();\r\n            this.sendImmediately(message);\r\n          }\r\n        };\r\n  \r\n        this.ws.onmessage = (event) => {\r\n          try {\r\n            const data = JSON.parse(event.data);\r\n            console.log('Parsed message:', data);\r\n            this.listeners.forEach((listener) => listener(data));\r\n          } catch (error) {\r\n            console.error('Error parsing message:', error);\r\n          }\r\n        };\r\n  \r\n        this.ws.onerror = (error) => {\r\n          console.error('WebSocket error:', error);\r\n          this.isConnected = false;\r\n        };\r\n  \r\n        this.ws.onclose = () => {\r\n          console.log('WebSocket connection closed');\r\n          this.isConnected = false;\r\n          // Attempt to reconnect\r\n          setTimeout(() => this.connect(url), 3000);\r\n        };\r\n      }\r\n    }\r\n  \r\n    sendImmediately(message) {\r\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\r\n        const messageString = JSON.stringify(message);\r\n        console.log('Sending message:', messageString);\r\n        this.ws.send(messageString);\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n  \r\n    send(message) {\r\n      if (this.isConnected && this.sendImmediately(message)) {\r\n        return true;\r\n      } else {\r\n        console.log('Queueing message because connection is not ready:', message);\r\n        this.messageQueue.push(message);\r\n        return false;\r\n      }\r\n    }\r\n  \r\n    addListener(listener) {\r\n      this.listeners.push(listener);\r\n    }\r\n  \r\n    removeListener(listener) {\r\n      this.listeners = this.listeners.filter((l) => l !== listener);\r\n    }\r\n  }\r\n  \r\n  const webSocketManager = new WebSocketManager();\r\n  export default webSocketManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}